bypass can skip preferred protocol for pushed releases (from autobrr)

--- a/src/NzbDrone.Core/DecisionEngine/DownloadDecisionMaker.cs
+++ b/src/NzbDrone.Core/DecisionEngine/DownloadDecisionMaker.cs
@@ -67,6 +67,23 @@
             }

             var reportNumber = 1;
+            var source = pushedRelease ? ReleaseSourceType.ReleasePush : ReleaseSourceType.Rss;
+
+            if (searchCriteria != null)
+            {
+                if (searchCriteria.InteractiveSearch)
+                {
+                    source = ReleaseSourceType.InteractiveSearch;
+                }
+                else if (searchCriteria.UserInvokedSearch)
+                {
+                    source = ReleaseSourceType.UserInvokedSearch;
+                }
+                else
+                {
+                    source = ReleaseSourceType.Search;
+                }
+            }

             foreach (var report in reports)
             {
@@ -92,6 +109,7 @@
                     {
                         var remoteEpisode = _parsingService.Map(parsedEpisodeInfo, report.TvdbId, report.TvRageId, searchCriteria);
                         remoteEpisode.Release = report;
+                        remoteEpisode.ReleaseSource = source;

                         if (remoteEpisode.Series == null)
                         {
@@ -138,7 +156,8 @@
                             {
                                 Release = report,
                                 ParsedEpisodeInfo = parsedEpisodeInfo,
-                                Languages = parsedEpisodeInfo.Languages
+                                Languages = parsedEpisodeInfo.Languages,
+                                ReleaseSource = source
                             };

                             decision = new DownloadDecision(remoteEpisode, new Rejection("Unable to parse release"));
@@ -149,7 +168,11 @@
                 {
                     _logger.Error(e, "Couldn't process release.");

-                    var remoteEpisode = new RemoteEpisode { Release = report };
+                    var remoteEpisode = new RemoteEpisode
+                    {
+                        Release = report,
+                        ReleaseSource = source
+                    };
                     decision = new DownloadDecision(remoteEpisode, new Rejection("Unexpected error processing release"));
                 }

@@ -157,26 +180,6 @@

                 if (decision != null)
                 {
-                    var source = pushedRelease ? ReleaseSourceType.ReleasePush : ReleaseSourceType.Rss;
-
-                    if (searchCriteria != null)
-                    {
-                        if (searchCriteria.InteractiveSearch)
-                        {
-                            source = ReleaseSourceType.InteractiveSearch;
-                        }
-                        else if (searchCriteria.UserInvokedSearch)
-                        {
-                            source = ReleaseSourceType.UserInvokedSearch;
-                        }
-                        else
-                        {
-                            source = ReleaseSourceType.Search;
-                        }
-                    }
-
-                    decision.RemoteEpisode.ReleaseSource = source;
-
                     if (decision.Rejections.Any())
                     {
                         _logger.Debug("Release '{0}' from '{1}' rejected for the following reasons: {2}", report.Title, report.Indexer, string.Join(", ", decision.Rejections));
--- a/src/NzbDrone.Core/DecisionEngine/Specifications/RssSync/DelaySpecification.cs
+++ b/src/NzbDrone.Core/DecisionEngine/Specifications/RssSync/DelaySpecification.cs
@@ -38,6 +38,7 @@
             var delayProfile = _delayProfileService.BestForTags(subject.Series.Tags);
             var delay = delayProfile.GetProtocolDelay(subject.Release.DownloadProtocol);
             var isPreferredProtocol = subject.Release.DownloadProtocol == delayProfile.PreferredProtocol;
+            var isPushedRelease = subject.ReleaseSource == ReleaseSourceType.ReleasePush;

             if (delay == 0)
             {
@@ -69,7 +70,7 @@
                 var bestQualityInProfile = qualityProfile.LastAllowedQuality();
                 var isBestInProfile = qualityComparer.Compare(subject.ParsedEpisodeInfo.Quality.Quality, bestQualityInProfile) >= 0;

-                if (isBestInProfile && isPreferredProtocol)
+                if (isBestInProfile && (isPreferredProtocol || isPushedRelease))
                 {
                     _logger.Debug("Quality is highest in profile for preferred protocol, will not delay");
                     return Decision.Accept();
@@ -82,7 +83,7 @@
                 var score = subject.CustomFormatScore;
                 var minimum = delayProfile.MinimumCustomFormatScore;

-                if (score >= minimum && isPreferredProtocol)
+                if (score >= minimum && (isPreferredProtocol || isPushedRelease))
                 {
                     _logger.Debug("Custom format score ({0}) meets minimum ({1}) for preferred protocol, will not delay", score, minimum);
                     return Decision.Accept();
