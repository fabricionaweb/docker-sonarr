bypass can skip preferred protocol for pushed releases (from autobrr)

--- a/src/NzbDrone.Core/DecisionEngine/DownloadDecisionMaker.cs
+++ b/src/NzbDrone.Core/DecisionEngine/DownloadDecisionMaker.cs
@@ -67,6 +67,7 @@
             }

             var reportNumber = 1;
+            var source = pushedRelease ? ReleaseSourceType.ReleasePush : ReleaseSourceType.Rss;

             foreach (var report in reports)
             {
@@ -92,6 +93,7 @@
                     {
                         var remoteEpisode = _parsingService.Map(parsedEpisodeInfo, report.TvdbId, report.TvRageId, searchCriteria);
                         remoteEpisode.Release = report;
+                        remoteEpisode.ReleaseSource = source;

                         if (remoteEpisode.Series == null)
                         {
@@ -138,7 +140,8 @@
                             {
                                 Release = report,
                                 ParsedEpisodeInfo = parsedEpisodeInfo,
-                                Languages = parsedEpisodeInfo.Languages
+                                Languages = parsedEpisodeInfo.Languages,
+                                ReleaseSource = source
                             };

                             decision = new DownloadDecision(remoteEpisode, new Rejection("Unable to parse release"));
@@ -157,8 +160,6 @@

                 if (decision != null)
                 {
-                    var source = pushedRelease ? ReleaseSourceType.ReleasePush : ReleaseSourceType.Rss;
-
                     if (searchCriteria != null)
                     {
                         if (searchCriteria.InteractiveSearch)
--- a/src/NzbDrone.Core/DecisionEngine/Specifications/RssSync/DelaySpecification.cs
+++ b/src/NzbDrone.Core/DecisionEngine/Specifications/RssSync/DelaySpecification.cs
@@ -38,6 +38,7 @@
             var delayProfile = _delayProfileService.BestForTags(subject.Series.Tags);
             var delay = delayProfile.GetProtocolDelay(subject.Release.DownloadProtocol);
             var isPreferredProtocol = subject.Release.DownloadProtocol == delayProfile.PreferredProtocol;
+            var isPushedRelease = subject.ReleaseSource == ReleaseSourceType.ReleasePush;

             if (delay == 0)
             {
@@ -69,7 +70,7 @@
                 var bestQualityInProfile = qualityProfile.LastAllowedQuality();
                 var isBestInProfile = qualityComparer.Compare(subject.ParsedEpisodeInfo.Quality.Quality, bestQualityInProfile) >= 0;

-                if (isBestInProfile && isPreferredProtocol)
+                if (isBestInProfile && (isPreferredProtocol || isPushedRelease))
                 {
                     _logger.Debug("Quality is highest in profile for preferred protocol, will not delay");
                     return Decision.Accept();
@@ -82,7 +83,7 @@
                 var score = subject.CustomFormatScore;
                 var minimum = delayProfile.MinimumCustomFormatScore;

-                if (score >= minimum && isPreferredProtocol)
+                if (score >= minimum && (isPreferredProtocol || isPushedRelease))
                 {
                     _logger.Debug("Custom format score ({0}) meets minimum ({1}) for preferred protocol, will not delay", score, minimum);
                     return Decision.Accept();
